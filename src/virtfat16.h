#pragma once
#include <cstdint>
#include <string.h>
#include <vector>
#include <cwchar>
#include <cstring>
#include <cstdlib>
#include <string>
#include <locale>
#include <codecvt>
#include <cmath>
#include <list>
#include <iterator>
#include <string.h>

class StaticFat {
public:
struct __attribute__((__packed__)) MBRBOOT {
    uint8_t boot1[75] = {0xFA,0xB8,0x0,0x10,0x8E,0xD0,0xBC,0x0,0xB0,0xB8,0x0,0x0,
0x8E,0xD8,0x8E,0xC0,0xFB,0xBE,0x0,0x7C,0xBF,0x0,0x6,0xB9,0x0,0x2,0xF3,0xA4,0xEA,
0x21,0x6,0x0,0x0,0xBE,0xBE,0x7,0x38,0x4,0x75,0xB,0x83,0xC6,0x10,0x81,0xFE,0xFE,
0x7,0x75,0xF3,0xEB,0x16,0xB4,0x2,0xB0,0x1,0xBB,0x0,0x7C,0xB2,0x80,0x8A,0x74,0x1,
0x8B,0x4C,0x2,0xCD,0x13,0xEA,0x0,0x7C,0x0,0x0,0xEB,0xFE};
    uint8_t boot2[365] = {0};
    uint8_t boot3[6] = {0x5,0x16,0x1D,0xA0,0x0,0x0};
};

struct __attribute__((__packed__)) MBRPART {
    uint8_t  BootIndicator         = 0x0;
    uint8_t  StartingHead          = 0x0;
    uint16_t StartingSectCylinder  = 0x0;
    uint8_t  SystemID              = 0x0;
    uint8_t  EndingHead            = 0x0;
    uint16_t EndingSectCylinder    = 0x0;
    uint32_t RelativeSector        = 0x0;
    uint32_t TotalSectors          = 0x0;
};

struct __attribute__((__packed__)) MBRFAT {
    MBRBOOT     boot;
    MBRPART     part1 {
        .StartingHead = 0x20,
        .StartingSectCylinder = 0x21,
        .SystemID = 0xE,
        .EndingHead = 0x71,
        .EndingSectCylinder = 0x1021,
        .RelativeSector = 0x800, //distance from mbr to fatboot
        .TotalSectors = 0x40000,
    };
    MBRPART    part2;
    MBRPART    part3;
    MBRPART    part4;
    uint16_t   EndOfSectorMarker = 0xAA55;
} mbrBlock;

struct __attribute__((__packed__)) FATBOOT {
    int8_t   BS_JmpBoot[3]     = {(int8_t)0xEB, (int8_t)0x3C, (int8_t)0x90};
    char     BS_OEMName[8]     = {'M','S','D','O','S','5','.','0'};
    uint16_t BPB_BytsPerSec    = 0x200; //512 bytes
    uint8_t  BPB_SecPerClus    = 0x40; // this * 512
    uint16_t BPB_ResvdSecCnt   = 0x8;
    uint8_t  BPB_NumFATs	   = 0x2;
    uint16_t BPB_RootEntCnt	   = 0x200;
    uint16_t BPB_TotSec16	   = 0x0;
    uint8_t  BPB_Media	       = 0xF8;
    uint16_t BPB_FATSz16	   = 0x10;
    uint16_t BPB_SecPerTrk     = 0x3F;
    uint16_t BPB_NumHeads	   = 0xFF;
    uint32_t BPB_HiddSec	   = 0x800;
    uint32_t BPB_TotSec32	   = 0x40000; 
    int8_t   BS_DrvNum	       = (int8_t)0x80;
    int8_t   BS_Reserved1	   = (int8_t)0x0;
    int8_t   BS_BootSig	       = (int8_t)0x29;
    uint32_t BS_VolID	       = 0x4FB1C94D;
    char     BS_VolLab[11]	   = {0};
    char     BS_FilSysType[8]  = {'F','A','T','1','6'};
    uint8_t  BootCode[448]     = {0x33,0xC9,0x8E,0xD1,0xBC,0xF0,0x7B,0x8E,0xD9,0xB8,0x0,0x20,0x8E,0xC0,
0xFC,0xBD,0x0,0x7C,0x38,0x4E,0x24,0x7D,0x24,0x8B,0xC1,0x99,0xE8,0x3C,0x1,0x72,0x1C,0x83,0xEB,0x3A,0x66,
0xA1,0x1C,0x7C,0x26,0x66,0x3B,0x7,0x26,0x8A,0x57,0xFC,0x75,0x6,0x80,0xCA,0x2,0x88,0x56,0x2,0x80,0xC3,
0x10,0x73,0xEB,0x33,0xC9,0x8A,0x46,0x10,0x98,0xF7,0x66,0x16,0x3,0x46,0x1C,0x13,0x56,0x1E,0x3,0x46,0xE,
0x13,0xD1,0x8B,0x76,0x11,0x60,0x89,0x46,0xFC,0x89,0x56,0xFE,0xB8,0x20,0x0,0xF7,0xE6,0x8B,0x5E,0xB,0x3,
0xC3,0x48,0xF7,0xF3,0x1,0x46,0xFC,0x11,0x4E,0xFE,0x61,0xBF,0x0,0x0,0xE8,0xE6,0x0,0x72,0x39,0x26,0x38,
0x2D,0x74,0x17,0x60,0xB1,0xB,0xBE,0xA1,0x7D,0xF3,0xA6,0x61,0x74,0x32,0x4E,0x74,0x9,0x83,0xC7,0x20,0x3B,
0xFB,0x72,0xE6,0xEB,0xDC,0xA0,0xFB,0x7D,0xB4,0x7D,0x8B,0xF0,0xAC,0x98,0x40,0x74,0xC,0x48,0x74,0x13,0xB4,
0xE,0xBB,0x7,0x0,0xCD,0x10,0xEB,0xEF,0xA0,0xFD,0x7D,0xEB,0xE6,0xA0,0xFC,0x7D,0xEB,0xE1,0xCD,0x16,0xCD,
0x19,0x26,0x8B,0x55,0x1A,0x52,0xB0,0x1,0xBB,0x0,0x0,0xE8,0x3B,0x0,0x72,0xE8,0x5B,0x8A,0x56,0x24,0xBE,
0xB,0x7C,0x8B,0xFC,0xC7,0x46,0xF0,0x3D,0x7D,0xC7,0x46,0xF4,0x29,0x7D,0x8C,0xD9,0x89,0x4E,0xF2,0x89,
0x4E,0xF6,0xC6,0x6,0x96,0x7D,0xCB,0xEA,0x3,0x0,0x0,0x20,0xF,0xB6,0xC8,0x66,0x8B,0x46,0xF8,0x66,0x3,
0x46,0x1C,0x66,0x8B,0xD0,0x66,0xC1,0xEA,0x10,0xEB,0x5E,0xF,0xB6,0xC8,0x4A,0x4A,0x8A,0x46,0xD,0x32,
0xE4,0xF7,0xE2,0x3,0x46,0xFC,0x13,0x56,0xFE,0xEB,0x4A,0x52,0x50,0x6,0x53,0x6A,0x1,0x6A,0x10,0x91,0x8B,
0x46,0x18,0x96,0x92,0x33,0xD2,0xF7,0xF6,0x91,0xF7,0xF6,0x42,0x87,0xCA,0xF7,0x76,0x1A,0x8A,0xF2,0x8A,
0xE8,0xC0,0xCC,0x2,0xA,0xCC,0xB8,0x1,0x2,0x80,0x7E,0x2,0xE,0x75,0x4,0xB4,0x42,0x8B,0xF4,0x8A,0x56,
0x24,0xCD,0x13,0x61,0x61,0x72,0xB,0x40,0x75,0x1,0x42,0x3,0x5E,0xB,0x49,0x75,0x6,0xF8,0xC3,0x41,0xBB,
0x0,0x0,0x60,0x66,0x6A,0x0,0xEB,0xB0,0x42,0x4F,0x4F,0x54,0x4D,0x47,0x52,0x20,0x20,0x20,0x20,0xD,0xA,
0x52,0x65,0x6D,0x6F,0x76,0x65,0x20,0x64,0x69,0x73,0x6B,0x73,0x20,0x6F,0x72,0x20,0x6F,0x74,0x68,0x65,
0x72,0x20,0x6D,0x65,0x64,0x69,0x61,0x2E,0xFF,0xD,0xA,0x44,0x69,0x73,0x6B,0x20,0x65,0x72,0x72,0x6F,
0x72,0xFF,0xD,0xA,0x50,0x72,0x65,0x73,0x73,0x20,0x61,0x6E,0x79,0x20,0x6B,0x65,0x79,0x20,0x74,0x6F,
0x20,0x72,0x65,0x73,0x74,0x61,0x72,0x74,0xD,0xA,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xAC,0xCB,0xD8};
    uint8_t  FSI_TrailSig[2]   = {0x55, 0xAA};
} fatBlock;
/*
struct __attribute__((__packed__)) FTABLE{
    uint8_t cluster1[12] = {0xFF,0xF8, 0xFF,0xFF, 0xFF,0xFF, 0xFF,0xFF, 0xFF,0xFF, 0xFF,0xFF};
    uint8_t cluster2[8180] = {0};
} fatTableBlock;*/



enum ATTR : uint8_t {
    ATTR_NONE       =   0x0,
    ATTR_READ_ONLY  =  	0x01, 
    ATTR_HIDDEN     =	0x02,
    ATTR_SYSTEM     =	0x04,
    ATTR_VOLUME_ID  =	0x08,
    ATTR_DIRECTORY  =	0x10,
    ATTR_ARCHIVE    =	0x20,
    ATTR_LONG_NAME  =	ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID,
};

struct __attribute__((__packed__)) DIR {
    char    DIR_Name[11]     = {0}; //Short name.
    ATTR      DIR_Attr       = ATTR_NONE; //NoneOrFile
    //Reserved for use by Windows NT. Set value to 0 when a file is created and never modify or look at it after that.
    uint8_t    DIR_NTRes     = 0;
    //Millisecond stamp at file creation time. This field actually contains a count of tenths of a second.
    //The granularity of the seconds part of DIR_CrtTime is 2 seconds so this field is a count of tenths
    //of a second and its valid value range is 0-199 inclusive.
    uint8_t DIR_CrtTimeTenth = 0;
    //Time file was created.
    int8_t DIR_CrtTime[2]    = {(int8_t)0x00, (int8_t)0x00};
    //Date file was created.
    int8_t DIR_CrtDate[2]    = {(int8_t)0x00, (int8_t)0x00};
    //Last access date. Note that there is no last access time, only a date.
    // This is the date of last read or write. In the case of a write, this
    // should be set to the same date as DIR_WrtDate.
    int8_t DIR_LstAccDate[2] = {(int8_t)0x00, (int8_t)0x00};
    //High word of this entry’s first cluster number (always 0 for a FAT12 or FAT16 volume).
    uint16_t DIR_FstClusHI   = 0;
    int8_t DIR_WrtTime[2]    = {(int8_t)0x00, (int8_t)0x00};
    int8_t DIR_WrtDate[2]    = {(int8_t)0x00, (int8_t)0x00};
    //Low word of this entry’s first cluster number.
    uint16_t DIR_FstClusLO   = 0;
    //32-bit DWORD holding this file’s size in bytes
    uint32_t DIR_FileSize    = 0;
};
/*
FAT: General Overfiew of On-Disk Format - Page 27
A set of long entries is always associated with a short entry that they always immediately precede.  

-Page 28
A long name can consist of more characters than can fit in a single long directory entry.
When this occurs the name is stored in more than one long entry.

Me: This means long entries are written in reverse
*/
struct __attribute__((__packed__)) LDIR {
    /* The order of this entry in the sequence of long dir entries associated with the short
    dir entry at the end of the long dir set. If masked with 0x40 (LAST_LONG_ENTRY), 
    this indicates the entry is the last long dir entry in a set of long dir entries.
    All valid sets of long dir entries must begin with an entry having this mask. */
    uint8_t LDIR_Ord = 0x0;
    //Characters 1-5 of the long-name sub-component in this dir entry.
    uint16_t LDIR_Name1[5] = {0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF};
    //Attributes - must be ATTR_LONG_NAME
    uint8_t LDIR_Attr = 15;
    //If zero, indicates a directory entry that is a sub-component of a long name. 
    //NOTE: Other values reserved for future extensions.
    uint8_t LDIR_Type = 0; 
    //Checksum of name in the short dir entry at the end of the long dir set.
    uint8_t LDIR_Chksum = 0x0;
    //Characters 6-11 of the long-name sub-component in this dir entry.
    uint16_t LDIR_Name2[6] = {0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF}; 
    //Must be ZERO. This is an artifact of the FAT "first cluster" and must be zero for compatibility
    // with existing disk utilities.  It's meaningless in the context of a long dir entry.
    uint16_t LDIR_FstClusLO = 0; 
    //Characters 12-13 of the long-name sub-component in this dir entry.
    uint16_t LDIR_Name3[2] = {0xFFFF,0xFFFF}; 
};

struct File {
    uint32_t startAddr = 0;
    uint32_t endAddr = 0;
    uint32_t fileSize = 0;
    int32_t (*cBackPtr) (uint32_t, uint32_t, uint8_t*, uint32_t, File*);
};

uint8_t zeroBlock[512] = {0};

uint32_t mbrStartAddr = 0x0;
uint32_t mbrEndAddr = 0x200;
uint32_t fatBStartAddr = mbrBlock.part1.RelativeSector * fatBlock.BPB_BytsPerSec;
uint32_t fatBEndAddr = fatBStartAddr + 0x200;
uint32_t tablesize = (fatBlock.BPB_FATSz16 * fatBlock.BPB_BytsPerSec);
uint32_t table1StartAddr = fatBStartAddr + (fatBlock.BPB_ResvdSecCnt * fatBlock.BPB_BytsPerSec);
uint32_t table1EndAddr = table1StartAddr + tablesize;
uint32_t table2StartAddr = table1EndAddr;
uint32_t table2EndAddr = table2StartAddr + tablesize;
uint32_t rootDirStartAddr = table2EndAddr;
uint32_t rootDirSize = fatBlock.BPB_RootEntCnt * 0x20;
uint32_t rootDirEndAddr = rootDirStartAddr + rootDirSize;

uint32_t RootDirBytes = ((fatBlock.BPB_RootEntCnt * 32) + (fatBlock.BPB_BytsPerSec - 1));
uint32_t RootDirSectors = RootDirBytes / fatBlock.BPB_BytsPerSec;
uint32_t FirstDataSector = fatBlock.BPB_ResvdSecCnt + (fatBlock.BPB_NumFATs * fatBlock.BPB_FATSz16) + RootDirSectors;
uint16_t fatTableBlock[0x2000/2] = {0xFFF8, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
uint32_t fatTableBlockPos = 5; //start after initial table data
//16,895
//root directory
struct __attribute__((__packed__)) ROOTDIRECTORY {
    DIR volume {
        .DIR_Name = {'C','a','r','d','b','o','a','r','d','6','4'},
        .DIR_Attr = ATTR::ATTR_VOLUME_ID,
    };

    uint8_t b[0x4000-0x20] = {0};
} rootDirBlock;
uint32_t rootDirPos = 0+32; //start after volume dir

//addresses and pointers to file callbacks
std::vector<File> filesVector;

// Reserved characters for FAT short 8.3 names.
inline bool sfnReservedChar(uint8_t c);
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c);

uint8_t lfnChecksum(uint8_t* name);

uint32_t readStaticFatDrive(uint32_t chunk, uint32_t offset, uint8_t * buffer, uint32_t bufferSize);
uint32_t addFileCallback(const char * name, uint32_t size,
int32_t (*cBackPtr) (uint32_t, uint32_t, uint8_t*, uint32_t, File*));
bool makeShortName(const char * name, char * outShortName);
void addShortDir(const char * name, ATTR attribute, uint16_t cluster, uint32_t size);
void addLongDir(const char * name, uint8_t chksum);

uint16_t addToTable(uint32_t bytes);

};